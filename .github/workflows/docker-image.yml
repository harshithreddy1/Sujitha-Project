name: Build → Push to ECR → Deploy to EC2 (ECR only)

on:
  workflow_dispatch:
    inputs:
      tag:
        description: 'Image tag to build & deploy (format: vMAJOR.MINOR.PATCH, e.g. v1.0.0)'
        required: true
        default: 'v1.0.0'

env:
  ECR_REGISTRY: "909688465000.dkr.ecr.ap-south-1.amazonaws.com"
  ECR_REPOSITORY: "ust/training"
  AWS_REGION: "ap-south-1"
  EC2_USER: "ec2-user"
  EC2_HOST: "43.204.231.70"
  EC2_SSH_PORT: "22"
  CONTAINER_NAME: "ust-training-app"
  HEALTHCHECK_PATH: "/"
  HEALTHCHECK_PORT: "3000"
  HEALTHCHECK_RETRIES: "12"
  HEALTHCHECK_SLEEP_SECONDS: "5"

jobs:
  build-push-deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: Validate image tag
        id: validate
        run: |
          TAG="${{ github.event.inputs.tag }}"
          echo "Provided tag: $TAG"
          if ! echo "$TAG" | grep -qE '^v[0-9]+\.[0-9]+\.[0-9]+$'; then
            echo "::error::Invalid tag format. Expected vMAJOR.MINOR.PATCH (example: v1.0.0)"
            exit 1
          fi
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure AWS credentials for runner
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Ensure ECR repository exists
        run: |
          aws ecr describe-repositories --repository-names "${ECR_REPOSITORY}" >/dev/null 2>&1 || \
            aws ecr create-repository --repository-name "${ECR_REPOSITORY}" >/dev/null
        env:
          ECR_REPOSITORY: ${{ env.ECR_REPOSITORY }}

      - name: Login Docker to ECR (runner)
        run: |
          aws ecr get-login-password --region "${AWS_REGION}" | docker login --username AWS --password-stdin "${ECR_REGISTRY}"
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
          ECR_REGISTRY: ${{ env.ECR_REGISTRY }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push Docker image to ECR (ECR only)
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ steps.validate.outputs.tag }}

      - name: Deploy to EC2 via SSH (appleboy)
        id: deploy_ssh
        uses: appleboy/ssh-action@v0.1.7
        with:
          host: ${{ env.EC2_HOST }}
          username: ${{ env.EC2_USER }}
          key: ${{ secrets.AWS_KEY_PAIR }}           # PEM content
          port: ${{ env.EC2_SSH_PORT }}
          timeout: 10m                              # <-- must include time unit
          script: |
            set -euxo pipefail
            TAG="${{ steps.validate.outputs.tag }}"
            IMAGE="${ECR_REGISTRY}/${ECR_REPOSITORY}:${TAG}"
            CONTAINER_NAME="${CONTAINER_NAME}"
            AWS_REGION="${AWS_REGION}"
            ECR_REGISTRY="${ECR_REGISTRY}"

            echo "Remote: starting deployment for ${IMAGE}"

            # Detect OS
            if [ -f /etc/os-release ]; then
              . /etc/os-release
              OS_ID="$ID"
            else
              OS_ID="unknown"
            fi
            echo "Remote: detected OS = ${OS_ID}"

            # Install Docker if not present
            if ! command -v docker >/dev/null 2>&1; then
              echo "Remote: Docker not found — installing..."
              if [ "${OS_ID}" = "amzn" ] || [ "${OS_ID}" = "amazon" ] || [ "${OS_ID}" = "centos" ] || [ "${OS_ID}" = "rhel" ]; then
                if command -v yum >/dev/null 2>&1; then
                  if command -v amazon-linux-extras >/dev/null 2>&1; then
                    sudo amazon-linux-extras install docker -y
                  else
                    sudo yum install -y docker
                  fi
                  sudo systemctl enable --now docker
                fi
              elif [ "${OS_ID}" = "ubuntu" ] || [ "${OS_ID}" = "debian" ]; then
                sudo apt-get update -y
                # full package name apt-transport-https (was truncated earlier)
                sudo apt-get install -y apt-transport-https ca-certificates curl gnupg-agent software-properties-common
                curl -fsSL https://download.docker.com/linux/${OS_ID}/gpg | sudo apt-key add -
                sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/${OS_ID} $(lsb_release -cs) stable"
                sudo apt-get update -y
                sudo apt-get install -y docker-ce docker-ce-cli containerd.io
                sudo systemctl enable --now docker
              else
                echo "Remote: Unknown OS; trying get.docker.com"
                curl -fsSL https://get.docker.com -o /tmp/get-docker.sh
                sudo sh /tmp/get-docker.sh
              fi
              if id ec2-user >/dev/null 2>&1; then
                sudo usermod -aG docker ec2-user || true
              fi
            else
              echo "Remote: docker already present: $(docker --version)"
            fi

            # Install AWS CLI if missing
            if ! command -v aws >/dev/null 2>&1; then
              echo "Remote: AWS CLI v2 not found — installing..."
              sudo apt-get update -y || true
              sudo apt-get install -y unzip || true
              curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o /tmp/awscliv2.zip
              unzip -q /tmp/awscliv2.zip -d /tmp
              sudo /tmp/aws/install || true
            else
              echo "Remote: aws present: $(aws --version)"
            fi

            # Validate AWS creds are present in environment (appleboy injects envs)
            if [ -z "${AWS_ACCESS_KEY_ID:-}" ] || [ -z "${AWS_SECRET_ACCESS_KEY:-}" ]; then
              echo "Remote: AWS credentials not present; aborting"
              exit 1
            fi

            echo "Remote: logging into ECR and pulling ${IMAGE}"
            aws ecr get-login-password --region "${AWS_REGION}" | docker login --username AWS --password-stdin "${ECR_REGISTRY}"
            docker pull "${IMAGE}"

            # Stop & remove previous container if exists
            if docker ps -a --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
              echo "Remote: stopping & removing ${CONTAINER_NAME}"
              docker rm -f "${CONTAINER_NAME}" || true
            fi

            # Run new container mapping 3000:3000
            docker run -d --name "${CONTAINER_NAME}" --restart unless-stopped -p 3000:3000 "${IMAGE}"

            echo "Remote: deployment finished"
            docker ps --format "table {{.Names}}\t{{.Image}}\t{{.Status}}\t{{.Ports}}"
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ env.AWS_REGION }}
          ECR_REGISTRY: ${{ env.ECR_REGISTRY }}
          ECR_REPOSITORY: ${{ env.ECR_REPOSITORY }}
          CONTAINER_NAME: ${{ env.CONTAINER_NAME }}

      - name: Wait for app and perform health-check
        id: health
        run: |
          HOST="${{ env.EC2_HOST }}"
          PATH="${{ env.HEALTHCHECK_PATH }}"
          PORT="${{ env.HEALTHCHECK_PORT }}"
          RETRIES=${{ env.HEALTHCHECK_RETRIES }}
          SLEEP=${{ env.HEALTHCHECK_SLEEP_SECONDS }}

          URL="http://${HOST}:${PORT}${PATH}"
          echo "Waiting for ${URL} to return HTTP 200..."

          i=0
          while [ $i -lt $RETRIES ]; do
            if curl -s -f -m 5 "${URL}" >/dev/null 2>&1; then
              echo "Health check passed on attempt $((i+1))"
              exit 0
            fi
            echo "Attempt $((i+1)) failed — retrying in ${SLEEP}s..."
            i=$((i+1))
            sleep ${SLEEP}
          done

          echo "::error::Health check failed after ${RETRIES} attempts: ${URL}"
          exit 1

      - name: Deployment result
        if: success()
        run: |
          echo "✅ Deployment succeeded!"
          echo "Application should be available at: http://${{ env.EC2_HOST }}:${{ env.HEALTHCHECK_PORT }}${{ env.HEALTHCHECK_PATH }}"
